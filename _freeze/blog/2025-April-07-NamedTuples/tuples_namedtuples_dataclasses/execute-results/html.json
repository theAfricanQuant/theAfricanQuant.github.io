{
  "hash": "07ab38a4db508185210ff76470218c0b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Python's Data Structures: Tuples, namedTuples & DataClasses (Retired Legends Edition)\"\nauthor: \"Ricky Macharm\"\ndate: \"7 April 2025\"\nimage: \"JJOkocha.jpeg\"\ncategories: [Python, collections, DataClasses, NamedTuple] # self-defined categories\nformat: html\nexecute:\n    eval: true\njupyter: python3\n---\n\n\n## Introduction\n\nEver needed to store a fixed collection of related items, like coordinates (x, y) or basic info about a person (name, age)? How about details for legendary retired football players, many of whom famously wore the number 10 jersey? Think Pelé, Zidane, Platini, and the skillful Jay-Jay Okocha! Python offers several ways to structure this data. We'll start with the basic `tuple` and see why sometimes we need more clarity. Then, we'll explore `collections.namedtuple`, its modern cousin `typing.NamedTuple`, and finally, the flexible `dataclass`, using these football icons as our examples! Let's dive in and make sense of these useful structures!\n\n## What's a Tuple?\n\nThink of a tuple as a fixed, ordered list. Once you create it, you can't change its contents – it's *immutable*. You define tuples using parentheses `()`. Let's store some basic player info.\n\n::: {#31188a39 .cell execution_count=1}\n``` {.python .cell-code}\n# A tuple representing basic player info (Name, Year of Birth)\nplatini_basic = (\"Michel Platini\", 1955)\nprint(f\"Basic Platini tuple: {platini_basic}\")\n\n# A tuple representing more detailed player info (Name, YOB, Country, Active Years)\n# Note: Pelé's full name is Edson Arantes do Nascimento\npele_details = (\"Pelé\", 1940, \"Brazil\", \"1956–1977\") \nprint(f\"Detailed Pelé tuple: {pele_details}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBasic Platini tuple: ('Michel Platini', 1955)\nDetailed Pelé tuple: ('Pelé', 1940, 'Brazil', '1956–1977')\n```\n:::\n:::\n\n\nYou access items in a tuple using their position (index), starting from 0.\n\n::: {#b6f6d7bc .cell execution_count=2}\n``` {.python .cell-code}\n# Continuing with the tuples from above\nplatini_basic = (\"Michel Platini\", 1955)\npele_details = (\"Pelé\", 1940, \"Brazil\", \"1956–1977\")\n\n# Accessing elements by their index\nplatini_name = platini_basic[0]\nplatini_yob = platini_basic[1]\n\npele_name = pele_details[0]\npele_country = pele_details[2]\npele_active = pele_details[3]\n\n\nprint(f\"Platini: Name = {platini_name}, YOB = {platini_yob}\")\nprint(f\"Pelé: Name = {pele_name}, Country = {pele_country}, Active = {pele_active}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPlatini: Name = Michel Platini, YOB = 1955\nPelé: Name = Pelé, Country = Brazil, Active = 1956–1977\n```\n:::\n:::\n\n\n**The Challenge with Simple Tuples:**\n\nUsing indices like `pele_details[2]` works, but it isn't very descriptive. What does index `2` represent? Country? Jersey number? Goals scored? This can get confusing, especially with tuples holding more items. We need a way to make accessing these elements more readable.\n\n## Making Tuples Readable: `collections.namedtuple`\n\nPython's built-in `collections` module provides a fantastic solution: `namedtuple`. It lets you create tuple-like objects where you can access elements by a descriptive *name* as well as by their index! It acts like a factory that generates a new *type* of tuple tailored to our player data needs, featuring greats like Okocha and Pelé.\n\n::: {#09c47665 .cell execution_count=3}\n``` {.python .cell-code}\nfrom collections import namedtuple\n\n# Create a 'blueprint' for a Player namedtuple\n# Fields: name, year_of_birth, country, years_active\nPlayer = namedtuple(\"Player\", \"name year_of_birth country years_active\")\n\n# Create instances (objects) of our Player namedtuple type\n# Data: Jay-Jay Okocha, Pelé\nokocha = Player(\"Jay-Jay Okocha\", 1973, \"Nigeria\", \"1992–2008\")\npele = Player(name=\"Pelé\", year_of_birth=1940, country=\"Brazil\", years_active=\"1956–1977\") # Keyword args work too\n\nprint(\"--- Player Instances ---\")\nprint(okocha)\nprint(pele)\n\n# Access by name (much clearer!)\nprint(\"\\n--- Access by Name ---\")\nprint(f\"Okocha's Country: {okocha.country}\")\nprint(f\"Pelé's Active Years: {pele.years_active}\")\n\n# Access by index (still works!)\nprint(\"\\n--- Access by Index ---\")\nprint(f\"Okocha's Name (Index 0): {okocha[0]}\")\nprint(f\"Pelé's YOB (Index 1): {pele[1]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n--- Player Instances ---\nPlayer(name='Jay-Jay Okocha', year_of_birth=1973, country='Nigeria', years_active='1992–2008')\nPlayer(name='Pelé', year_of_birth=1940, country='Brazil', years_active='1956–1977')\n\n--- Access by Name ---\nOkocha's Country: Nigeria\nPelé's Active Years: 1956–1977\n\n--- Access by Index ---\nOkocha's Name (Index 0): Jay-Jay Okocha\nPelé's YOB (Index 1): 1940\n```\n:::\n:::\n\n\nSee how `okocha.country` and `pele.years_active` are much clearer than `okocha[2]` and `pele[3]`? This significantly improves code readability.\n\n`namedtuple` also comes with some handy built-in helper methods:\n\n::: {#6ad8ce05 .cell execution_count=4}\n``` {.python .cell-code}\nfrom collections import namedtuple\n\nPlayer = namedtuple(\"Player\", \"name year_of_birth country years_active\")\nokocha = Player(\"Jay-Jay Okocha\", 1973, \"Nigeria\", \"1992–2008\")\n\n# _asdict(): Get fields as an ordered dictionary\nprint(f\"Okocha as Dictionary: {okocha._asdict()}\")\n\n# _fields: Get the field names as a tuple\nprint(f\"Player Fields: {Player._fields}\") # Access fields via the type\n\n# _make(): Create a new instance from an iterable (like a list or tuple)\n# Data: Zinedine Zidane\nzidane_data = [\"Zinedine Zidane\", 1972, \"France\", \"1988–2006\"]\nzidane = Player._make(zidane_data)\nprint(f\"\\nMade from list (Zidane): {zidane}\")\n\n# _replace(): Create a *new* tuple with some fields replaced\n# Remember, tuples are immutable! This doesn't change okocha.\n# Let's imagine updating Okocha's active years hypothetically\nokocha_updated = okocha._replace(years_active=\"1992-2010\") # Creates a new instance\nprint(f\"\\nReplaced years (hypothetical): {okocha_updated}\")\nprint(f\"Original Okocha unchanged: {okocha}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOkocha as Dictionary: {'name': 'Jay-Jay Okocha', 'year_of_birth': 1973, 'country': 'Nigeria', 'years_active': '1992–2008'}\nPlayer Fields: ('name', 'year_of_birth', 'country', 'years_active')\n\nMade from list (Zidane): Player(name='Zinedine Zidane', year_of_birth=1972, country='France', years_active='1988–2006')\n\nReplaced years (hypothetical): Player(name='Jay-Jay Okocha', year_of_birth=1973, country='Nigeria', years_active='1992-2010')\nOriginal Okocha unchanged: Player(name='Jay-Jay Okocha', year_of_birth=1973, country='Nigeria', years_active='1992–2008')\n```\n:::\n:::\n\n\n## The Modern Way: `typing.NamedTuple`\n\nWith the introduction of type hints in Python 3, a more modern way to create named tuples emerged: `typing.NamedTuple`. It integrates seamlessly with type checking tools.\n\nThere are two main ways to define a `typing.NamedTuple`:\n\n**1. Functional Syntax:** Similar to `collections.namedtuple`, but includes type information directly in the field definition.\n\n::: {#dc7e62a6 .cell execution_count=5}\n``` {.python .cell-code}\nfrom typing import NamedTuple\n\n# Functional syntax: Define type name and a list of (field_name, type) tuples\nPlayerInfo = NamedTuple(\"PlayerInfo\", [\n    (\"name\", str),\n    (\"year_of_birth\", int),\n    (\"country\", str),\n    (\"years_active\", str)\n])\n\n# Create an instance using this type\nokocha_info = PlayerInfo(\"Jay-Jay Okocha\", 1973, \"Nigeria\", \"1992-2008\")\nzidane_info = PlayerInfo(name=\"Zinedine Zidane\", year_of_birth=1972, country=\"France\", years_active=\"1988–2006\")\n\nprint(\"--- Player Instances (typing.NamedTuple - Functional) ---\")\nprint(okocha_info)\nprint(zidane_info)\n\nprint(\"\\n--- Access by Name ---\")\nprint(f\"Okocha's Country: {okocha_info.country}\")\nprint(f\"Zidane's YOB: {zidane_info.year_of_birth}\")\n\nprint(\"\\n--- Access by Index ---\")\nprint(f\"Okocha's Name (Index 0): {okocha_info[0]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n--- Player Instances (typing.NamedTuple - Functional) ---\nPlayerInfo(name='Jay-Jay Okocha', year_of_birth=1973, country='Nigeria', years_active='1992-2008')\nPlayerInfo(name='Zinedine Zidane', year_of_birth=1972, country='France', years_active='1988–2006')\n\n--- Access by Name ---\nOkocha's Country: Nigeria\nZidane's YOB: 1972\n\n--- Access by Index ---\nOkocha's Name (Index 0): Jay-Jay Okocha\n```\n:::\n:::\n\n\n**2. Class Syntax:** This uses standard class definition syntax, which many find more intuitive and familiar, especially when coming from object-oriented programming.\n\n::: {#4f5b277a .cell execution_count=6}\n``` {.python .cell-code}\nfrom typing import NamedTuple\nimport datetime # To calculate age\n\n# Define a Player using NamedTuple and type hints\n# This looks like defining a class!\nclass Player(NamedTuple):\n    name: str\n    year_of_birth: int\n    country: str\n    years_active: str\n    # NOTE: We are keeping this definition simple for clarity.\n    # You *can* add methods here if needed, but the core idea\n    # is an immutable, typed structure.\n\n# Create instances - works just like calling a class constructor\n# Data: Michel Platini, Zinedine Zidane, Jay-Jay Okocha\nplatini = Player(\"Michel Platini\", 1955, \"France\", \"1972–1987\")\nzidane = Player(name=\"Zinedine Zidane\", year_of_birth=1972, country=\"France\", years_active=\"1988–2006\")\nokocha = Player(name=\"Jay-Jay Okocha\", year_of_birth=1973, country=\"Nigeria\", years_active=\"1992–2008\")\n\nprint(\"--- Player Instances (typing.NamedTuple - Class Syntax) ---\")\nprint(platini)\nprint(zidane)\nprint(okocha)\n\n\nprint(\"\\n--- Access by Name ---\")\nprint(f\"Platini's YOB: {platini.year_of_birth}\")\nprint(f\"Zidane's Country: {zidane.country}\")\nprint(f\"Okocha's Active Years: {okocha.years_active}\")\n\n\n# Access by index still works too!\nprint(f\"\\n--- Access by Index ---\")\nprint(f\"Platini's Name (Index 0): {platini[0]}\")\nprint(f\"Zidane's Active Years (Index 3): {zidane[3]}\")\nprint(f\"Okocha's YOB (Index 1): {okocha[1]}\")\n\n\n# Still immutable! This would raise an AttributeError:\n# try:\n#    zidane.country = \"Algeria\" # Can't change fields\n# except AttributeError as e:\n#    print(f\"\\nError trying to modify: {e}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n--- Player Instances (typing.NamedTuple - Class Syntax) ---\nPlayer(name='Michel Platini', year_of_birth=1955, country='France', years_active='1972–1987')\nPlayer(name='Zinedine Zidane', year_of_birth=1972, country='France', years_active='1988–2006')\nPlayer(name='Jay-Jay Okocha', year_of_birth=1973, country='Nigeria', years_active='1992–2008')\n\n--- Access by Name ---\nPlatini's YOB: 1955\nZidane's Country: France\nOkocha's Active Years: 1992–2008\n\n--- Access by Index ---\nPlatini's Name (Index 0): Michel Platini\nZidane's Active Years (Index 3): 1988–2006\nOkocha's YOB (Index 1): 1973\n```\n:::\n:::\n\n\nNotice how the class syntax looks much more like defining a regular Python class. It provides the same core benefits as `collections.namedtuple` (access by name, immutability, tuple behavior) but with the added advantages of:\n\n1.  **Clear Type Annotations:** Improves code understanding and helps catch errors.\n2.  **Standard Class Syntax:** More familiar for object-oriented programming.\n\n## NamedTuple *is* (almost) a Class\n\nIt's important to understand that both `collections.namedtuple` and `typing.NamedTuple` create actual Python classes for you behind the scenes. These generated classes inherit directly from the base `tuple` type. That's why they behave like tuples (immutable, ordered, unpackable, indexed) but *also* gain named fields. `typing.NamedTuple` just makes this class-based nature much more explicit, especially with the class syntax.\n\n## What About `dataclasses`?\n\nPython 3.7 introduced another powerful tool for creating classes that primarily hold data: the `@dataclass` decorator from the `dataclasses` module. It automatically generates special methods like `__init__`, `__repr__`, `__eq__`, etc., saving you boilerplate code. Let's model our retired legends using a dataclass.\n\n::: {#7fb22bd8 .cell execution_count=7}\n``` {.python .cell-code}\nfrom dataclasses import dataclass, field # field might be needed for complex defaults\n\n@dataclass\nclass PlayerData:\n    name: str\n    year_of_birth: int\n    country: str\n    years_active: str\n    # Example: Add an optional field with a simple default\n    status: str = \"Retired Legend\" \n\n    # You can add methods here too\n    def get_info_string(self) -> str:\n        return f\"{self.name} ({self.country}), Born: {self.year_of_birth}, Active: {self.years_active}, Status: {self.status}\"\n\n\n# Create instances - the __init__ is generated for us!\n# Data: Pelé, Jay-Jay Okocha\npele_dc = PlayerData(\"Pelé\", 1940, \"Brazil\", \"1956–1977\") \nokocha_dc = PlayerData(\"Jay-Jay Okocha\", 1973, \"Nigeria\", \"1992–2008\")\n\n\nprint(\"--- Player Instances (dataclass) ---\")\nprint(pele_dc) # Nice __repr__ is generated!\nprint(okocha_dc)\n\n# Dataclasses are MUTABLE by default\nprint(\"\\n--- Mutability ---\")\n# Let's hypothetically update Pelé's status if new info came to light\npele_dc.status = \"Global Ambassador\"\nprint(f\"Modified Pelé data: {pele_dc}\")\n\n# Comparison works out of the box (__eq__ is generated)\npele_dc_copy = PlayerData(\"Pelé\", 1940, \"Brazil\", \"1956–1977\", status=\"Global Ambassador\")\nokocha_dc_copy = PlayerData(\"Jay-Jay Okocha\", 1973, \"Nigeria\", \"1992–2008\")\n\nprint(f\"\\nIs pele_dc equal to its copy? {pele_dc == pele_dc_copy}\") # Compares field values\nprint(f\"Is okocha_dc equal to its copy? {okocha_dc == okocha_dc_copy}\")\nprint(f\"Is pele_dc equal to okocha_dc? {pele_dc == okocha_dc}\")\n\n# Use the custom method\nprint(\"\\n--- Custom Method ---\")\nprint(okocha_dc.get_info_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n--- Player Instances (dataclass) ---\nPlayerData(name='Pelé', year_of_birth=1940, country='Brazil', years_active='1956–1977', status='Retired Legend')\nPlayerData(name='Jay-Jay Okocha', year_of_birth=1973, country='Nigeria', years_active='1992–2008', status='Retired Legend')\n\n--- Mutability ---\nModified Pelé data: PlayerData(name='Pelé', year_of_birth=1940, country='Brazil', years_active='1956–1977', status='Global Ambassador')\n\nIs pele_dc equal to its copy? True\nIs okocha_dc equal to its copy? True\nIs pele_dc equal to okocha_dc? False\n\n--- Custom Method ---\nJay-Jay Okocha (Nigeria), Born: 1973, Active: 1992–2008, Status: Retired Legend\n```\n:::\n:::\n\n\n## `typing.NamedTuple` vs. `dataclasses.dataclass`: When to Choose?\n\nBoth `typing.NamedTuple` and `dataclasses.dataclass` are excellent for structured data, but they differ crucially:\n\n1.  **Mutability:**\n    * `NamedTuple`: **Immutable**. Cannot change values after creation. Create a new instance for changes (using `_replace` or creating anew).\n    * `DataClass`: **Mutable** by default. Can change values (`pele_dc.status = ...`). Use `@dataclass(frozen=True)` to make it immutable, mimicking `NamedTuple` behavior.\n\n2.  **Inheritance & Type:**\n    * `NamedTuple`: Inherits from `tuple`. *Is* a tuple.\n    * `DataClass`: Inherits from `object` (by default). A regular class instance, not a tuple.\n\n3.  **Memory & Performance:**\n    * `NamedTuple` *can* be slightly more memory-efficient (no `__dict__` usually needed).\n    * Performance differences are often negligible in practice. **Choose based on required features (mutability, tuple behavior) first.**\n\n4.  **Flexibility & Features:**\n    * `DataClass`: More flexible, more configuration options (`frozen`, `order`, `__post_init__`), easier handling of mutable defaults (`field(default_factory=...)`), feels like a standard class, easier to add complex methods.\n    * `NamedTuple`: Simpler, focused on immutable, tuple-like records with named fields and types.\n\n**When to Use Which (Retired Player Example Context):**\n\n* **Choose `typing.NamedTuple` for Players like Okocha, Pelé, Zidane when:**\n    * You want to ensure player records (like historical stats, birth year, active years) **cannot be accidentally changed** after creation. This represents fixed historical data well.\n    * You need to use the player record exactly like a `tuple` (e.g., as a dictionary key, unpacking into variables).\n    * You're returning fixed player info from a function and want named fields plus type safety for clarity without the overhead or mutability of a full class.\n\n* **Choose `dataclasses.dataclass` for Players when:**\n    * You need to **modify** player data after creation (e.g., updating `status`, adding recent accolades, potentially tracking temporary states).\n    * You want the *option* of immutability (`frozen=True`) but prefer the general structure and features of dataclasses (like easier method addition, `__post_init__`).\n    * You plan to add more complex methods related to player actions or state changes that go beyond simple data representation.\n    * You prefer the standard Python class feel and don't specifically need tuple-like behavior.\n\n## Conclusion\n\nWe've explored how to represent structured data in Python, moving from basic `tuple`s to more descriptive and powerful options using retired football legends like Pelé, Zidane, Platini, and the exceptionally skillful Jay-Jay Okocha (many of whom wore the iconic number 10) as our examples:\n\n* **`tuple`**: Simple, immutable, indexed sequence. Good for very basic, fixed data where names aren't crucial.\n* **`collections.namedtuple`**: The classic way to add names to tuple fields for readability, creating simple tuple subclasses.\n* **`typing.NamedTuple`**: The modern, type-hinted way (using functional or class syntax) for creating *immutable* named tuple classes. Excellent for fixed records.\n* **`dataclasses.dataclass`**: A flexible decorator for creating data-centric classes (*mutable* by default, but can be `frozen`) with less boilerplate code. Great for general-purpose data holding.\n\nUnderstanding the **immutability** of tuples and `NamedTuple` versus the default **mutability** of `dataclass` is key. Choose `NamedTuple` for fixed, unchanging records like historical player details or trading strategy backtest results that should remain tamper-proof. Opt for `dataclass` when you need a more general-purpose container, perhaps for data that might evolve or require more complex class behaviors. Both help write cleaner, more understandable Python code! Happy coding!\n\n",
    "supporting": [
      "tuples_namedtuples_dataclasses_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}