{
  "hash": "b8e263e82a802dd0391bfd5d61fa48ca",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Grokking the Unpacking Operator\"\nauthor: \"Ricky Macharm\"\ndate: \"14 September 2024\"\nimage: unboxing.webp\ncategories: [Python, Unpacking Operator, Method Chaining] # self-defined categories\nformat: html\nexecute:\n    eval: true\njupyter: python3\n---\n\n\n\n\n\n\n# Introduction\n\nImagine for a moment that it is your spouse's birthday and you planned to buy them a gift - a box with some selected items: jewelry, a watch, perfume, and airpods. You gleefully look at her/him smile as s/he unboxes it, carefully revealing each item one by one.\n\nSimilarly, in Python, unpacking allows us to unbox the elements of an iterable such as a list, tuple, or dictionary into individual variables. \n\nIn this article, we will get into the weeds of how python unboxes items, properly known as  **unpacking**.\n\n## The Basics of Unpacking\n\nLet's start simple. Unpacking is the process of extracting individual elements from a collection like a list or a tuple and assigning them to variables. Think of it like unboxing your wife's birthday gift. Here's how we do that in Python:\n\n::: {#28b629aa .cell execution_count=1}\n``` {.python .cell-code}\ngift_box = ['jewelry', 'watch', 'perfume', 'airpods']\nitem1, item2, item3, item4 = gift_box\n\nprint(item1)  # 'jewelry'\nprint(item2)  # 'watch'\nprint(item3)  # 'perfume'\nprint(item4)  # 'airpods'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njewelry\nwatch\nperfume\nairpods\n```\n:::\n:::\n\n\nHere, we \"unbox\" the list by assigning each item to a separate variable. Now, each variable contains one of the items from the `gift_box`.\n\n### What Happens if There Are Too Many or Too Few Items?\n\nWhat happens if the gift box has more items than variables?\n\n::: {#3bf9b34b .cell execution_count=2}\n``` {.python .cell-code}\ngift_box = ['jewelry', 'watch', 'perfume', 'airpods', 'flowers']\nitem1, item2, item3 = gift_box  # Error: too many values to unpack\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">ValueError</span>                                Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[2]</span><span class=\"ansi-green-fg\">, line 2</span>\n<span class=\"ansi-green-fg\">      1</span> gift_box = [<span class=\"ansi-yellow-fg\">'</span><span class=\"ansi-yellow-fg\">jewelry</span><span class=\"ansi-yellow-fg\">'</span>, <span class=\"ansi-yellow-fg\">'</span><span class=\"ansi-yellow-fg\">watch</span><span class=\"ansi-yellow-fg\">'</span>, <span class=\"ansi-yellow-fg\">'</span><span class=\"ansi-yellow-fg\">perfume</span><span class=\"ansi-yellow-fg\">'</span>, <span class=\"ansi-yellow-fg\">'</span><span class=\"ansi-yellow-fg\">airpods</span><span class=\"ansi-yellow-fg\">'</span>, <span class=\"ansi-yellow-fg\">'</span><span class=\"ansi-yellow-fg\">flowers</span><span class=\"ansi-yellow-fg\">'</span>]\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">2</span> item1, item2, item3 = gift_box  <span style=\"font-style:italic;color:rgb(95,135,135)\"># Error: too many values to unpack</span>\n\n<span class=\"ansi-red-fg\">ValueError</span>: too many values to unpack (expected 3)</pre>\n```\n:::\n\n:::\n:::\n\n\nWe get an error! Python doesn't know how to fit five items into just three variables. Likewise, if we had too few items, we'd also get an error:\n\n::: {#d59a9e49 .cell execution_count=3}\n``` {.python .cell-code}\ngift_box = ['jewelry', 'watch']\nitem1, item2, item3 = gift_box  # Error: not enough values to unpack\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">ValueError</span>                                Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[3]</span><span class=\"ansi-green-fg\">, line 2</span>\n<span class=\"ansi-green-fg\">      1</span> gift_box = [<span class=\"ansi-yellow-fg\">'</span><span class=\"ansi-yellow-fg\">jewelry</span><span class=\"ansi-yellow-fg\">'</span>, <span class=\"ansi-yellow-fg\">'</span><span class=\"ansi-yellow-fg\">watch</span><span class=\"ansi-yellow-fg\">'</span>]\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">2</span> item1, item2, item3 = gift_box  <span style=\"font-style:italic;color:rgb(95,135,135)\"># Error: not enough values to unpack</span>\n\n<span class=\"ansi-red-fg\">ValueError</span>: not enough values to unpack (expected 3, got 2)</pre>\n```\n:::\n\n:::\n:::\n\n\n## Unpacking with the `*` Operator\n\nNow, imagine you want to only unpack the first and last items from the gift box, while ignoring the rest. This is where the `*` operator comes in handy:\n\n::: {#83577e6a .cell execution_count=4}\n``` {.python .cell-code}\ngift_box = ['jewelry', 'watch', 'perfume', 'airpods', 'flowers']\nfirst, *middle, last = gift_box\n\nprint(first)  # 'jewelry'\nprint(last)   # 'flowers'\nprint(middle)  # ['watch', 'perfume', 'airpods']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njewelry\nflowers\n['watch', 'perfume', 'airpods']\n```\n:::\n:::\n\n\nThe `*` operator captures the remaining elements and packs them into a list. You can even discard them by using `_`:\n\n::: {#cce9cb2b .cell execution_count=5}\n``` {.python .cell-code}\nfirst, *_, last = gift_box\nprint(first, last)  # 'jewelry', 'flowers'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njewelry flowers\n```\n:::\n:::\n\n\nThis method is incredibly useful when you only care about a few elements in a list or tuple.\n\n## Unpacking Dictionaries with `**`\n\nNow let's move on to unpacking dictionaries. Imagine the gift contains a dictionary with item names and their respective values.\n\n::: {#353622be .cell execution_count=6}\n``` {.python .cell-code}\ngift_details = {'jewelry': 'gold', 'watch': 'rolex', 'perfume': 'Chanel'}\n```\n:::\n\n\nYou can unpack dictionaries using `**`. This is especially useful when you want to merge dictionaries, like adding more gifts in your spouse's box of gifts:\n\n::: {#26e411e5 .cell execution_count=7}\n``` {.python .cell-code}\nextra_gift = {'airpods': 'pro'}\nmerged_gifts = {**gift_details, **extra_gift}\nprint(merged_gifts)\n# {'jewelry': 'gold', 'watch': 'rolex', 'perfume': 'Chanel', 'airpods': 'pro'}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'jewelry': 'gold', 'watch': 'rolex', 'perfume': 'Chanel', 'airpods': 'pro'}\n```\n:::\n:::\n\n\nThe `**` operator spreads out the dictionary and allows you to combine multiple dictionaries into one.\n\n## Using `*args` and `**kwargs` in Functions\n\nYou might have seen the terms `*args` and `**kwargs` before in Python. These are used when defining functions to accept a variable number of arguments and keyword arguments.\n\n- `*args` lets you pass a variable number of positional arguments to a function.\n- `**kwargs` lets you pass a variable number of keyword arguments.\n\nLet’s start with `*args`:\n\n::: {#9c6d24bd .cell execution_count=8}\n``` {.python .cell-code}\ndef calculate_total(*args):\n    return sum(args)\n\nprint(calculate_total(10, 20, 30))  # 60\nprint(calculate_total(5, 15))  # 20\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n60\n20\n```\n:::\n:::\n\n\nHere, `*args` captures all the positional arguments into a tuple. You can pass as many arguments as you like.\n\nNext, let's look at `**kwargs`:\n\n::: {#b1c97a7b .cell execution_count=9}\n``` {.python .cell-code}\ndef print_gift_details(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_gift_details(jewelry=\"gold\", watch=\"rolex\", perfume=\"Chanel\")\n# jewelry: gold\n# watch: rolex\n# perfume: Chanel\n```\n\n::: {.cell-output .cell-output-stdout}\n```\njewelry: gold\nwatch: rolex\nperfume: Chanel\n```\n:::\n:::\n\n\nWith `**kwargs`, all keyword arguments are captured into a dictionary, which you can iterate over.\n\n### Combining `*args` and `**kwargs`\n\nYou can combine both in a function to accept any number of positional and keyword arguments:\n\n::: {#31bd4fd2 .cell execution_count=10}\n``` {.python .cell-code}\ndef gift_summary(*args, **kwargs):\n    print(\"Items:\", args)\n    print(\"Details:\", kwargs)\n\ngift_summary('jewelry', 'watch', jewelry=\"gold\", watch=\"rolex\")\n# Items: ('jewelry', 'watch')\n# Details: {'jewelry': 'gold', 'watch': 'rolex'}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nItems: ('jewelry', 'watch')\nDetails: {'jewelry': 'gold', 'watch': 'rolex'}\n```\n:::\n:::\n\n\n## Method Chaining  \n\nMethod chaining in pandas is a technique where multiple methods are called sequentially on a DataFrame or Series in a single statement. Each method operates on the output of the previous one, making the code concise and readable. It helps avoid intermediate variables and enables efficient data processing.\n\nlet us create a dataframe from the numpy library:\n\n::: {#7749c9e2 .cell execution_count=11}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np \n# Setting up random number generator\nrng = np.random.default_rng(seed=42)\n\n# Generating random data for open, high, low, close prices\ndata = {\n    'Open': rng.uniform(low=100, high=200, size=10),\n    'High': rng.uniform(low=200, high=300, size=10),\n    'Low': rng.uniform(low=50, high=100, size=10),\n    'Close': rng.uniform(low=100, high=200, size=10)\n}\n\n# Creating the DataFrame\ndf = pd.DataFrame(data).round(4)\ndf1=df2=df.copy() # making copies to use for examples later. \ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Open</th>\n      <th>High</th>\n      <th>Low</th>\n      <th>Close</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>177.3956</td>\n      <td>237.0798</td>\n      <td>87.9044</td>\n      <td>174.4762</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>143.8878</td>\n      <td>292.6765</td>\n      <td>67.7263</td>\n      <td>196.7510</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>185.8598</td>\n      <td>264.3865</td>\n      <td>98.5349</td>\n      <td>132.5825</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>169.7368</td>\n      <td>282.2762</td>\n      <td>94.6561</td>\n      <td>137.0460</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>109.4177</td>\n      <td>244.3414</td>\n      <td>88.9192</td>\n      <td>146.9556</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>197.5622</td>\n      <td>222.7239</td>\n      <td>59.7319</td>\n      <td>118.9471</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>176.1140</td>\n      <td>255.4585</td>\n      <td>73.3361</td>\n      <td>112.9922</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>178.6064</td>\n      <td>206.3817</td>\n      <td>52.1902</td>\n      <td>147.5705</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>112.8114</td>\n      <td>282.7631</td>\n      <td>57.7145</td>\n      <td>122.6909</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>145.0386</td>\n      <td>263.1664</td>\n      <td>84.1524</td>\n      <td>166.9814</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTo add a new feature like calculating the moving average of the Close price in a DataFrame, you can use the `rolling()` function in pandas. Here's how to calculate the moving average (for example, a 3-period moving average) of the Close price and add it as a new column to the DataFrame.\n\n::: {#4e55406d .cell execution_count=12}\n``` {.python .cell-code}\ndf1['SMA'] = df1['Close'].rolling(window=3).mean()\ndf1\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Open</th>\n      <th>High</th>\n      <th>Low</th>\n      <th>Close</th>\n      <th>SMA</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>177.3956</td>\n      <td>237.0798</td>\n      <td>87.9044</td>\n      <td>174.4762</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>143.8878</td>\n      <td>292.6765</td>\n      <td>67.7263</td>\n      <td>196.7510</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>185.8598</td>\n      <td>264.3865</td>\n      <td>98.5349</td>\n      <td>132.5825</td>\n      <td>167.936567</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>169.7368</td>\n      <td>282.2762</td>\n      <td>94.6561</td>\n      <td>137.0460</td>\n      <td>155.459833</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>109.4177</td>\n      <td>244.3414</td>\n      <td>88.9192</td>\n      <td>146.9556</td>\n      <td>138.861367</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>197.5622</td>\n      <td>222.7239</td>\n      <td>59.7319</td>\n      <td>118.9471</td>\n      <td>134.316233</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>176.1140</td>\n      <td>255.4585</td>\n      <td>73.3361</td>\n      <td>112.9922</td>\n      <td>126.298300</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>178.6064</td>\n      <td>206.3817</td>\n      <td>52.1902</td>\n      <td>147.5705</td>\n      <td>126.503267</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>112.8114</td>\n      <td>282.7631</td>\n      <td>57.7145</td>\n      <td>122.6909</td>\n      <td>127.751200</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>145.0386</td>\n      <td>263.1664</td>\n      <td>84.1524</td>\n      <td>166.9814</td>\n      <td>145.747600</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTo achieve the same using method chaining:\n\n::: {#7abaef14 .cell execution_count=13}\n``` {.python .cell-code}\ndf2 = (df2\n.assign(SMA=lambda x: x['Close'].rolling(window=3)\n.mean())\n)\ndf2\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Open</th>\n      <th>High</th>\n      <th>Low</th>\n      <th>Close</th>\n      <th>SMA</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>177.3956</td>\n      <td>237.0798</td>\n      <td>87.9044</td>\n      <td>174.4762</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>143.8878</td>\n      <td>292.6765</td>\n      <td>67.7263</td>\n      <td>196.7510</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>185.8598</td>\n      <td>264.3865</td>\n      <td>98.5349</td>\n      <td>132.5825</td>\n      <td>167.936567</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>169.7368</td>\n      <td>282.2762</td>\n      <td>94.6561</td>\n      <td>137.0460</td>\n      <td>155.459833</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>109.4177</td>\n      <td>244.3414</td>\n      <td>88.9192</td>\n      <td>146.9556</td>\n      <td>138.861367</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>197.5622</td>\n      <td>222.7239</td>\n      <td>59.7319</td>\n      <td>118.9471</td>\n      <td>134.316233</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>176.1140</td>\n      <td>255.4585</td>\n      <td>73.3361</td>\n      <td>112.9922</td>\n      <td>126.298300</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>178.6064</td>\n      <td>206.3817</td>\n      <td>52.1902</td>\n      <td>147.5705</td>\n      <td>126.503267</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>112.8114</td>\n      <td>282.7631</td>\n      <td>57.7145</td>\n      <td>122.6909</td>\n      <td>127.751200</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>145.0386</td>\n      <td>263.1664</td>\n      <td>84.1524</td>\n      <td>166.9814</td>\n      <td>145.747600</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThis seems to be working just fine. However, sometimes we might want to create a function that could insert multiple features at once based off of the users' choice. An example is given below:\n\n::: {#68be00ec .cell execution_count=14}\n``` {.python .cell-code}\ndef add_multiple_smas(df, col, *windows):\n    for window in windows:\n      df[f'SMA_{window}'] = df[col].rolling(window=window).mean()\n    return df\n\n# Example usage\nadd_multiple_smas(df1, 'Close', 2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Open</th>\n      <th>High</th>\n      <th>Low</th>\n      <th>Close</th>\n      <th>SMA</th>\n      <th>SMA_2</th>\n      <th>SMA_3</th>\n      <th>SMA_4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>177.3956</td>\n      <td>237.0798</td>\n      <td>87.9044</td>\n      <td>174.4762</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>143.8878</td>\n      <td>292.6765</td>\n      <td>67.7263</td>\n      <td>196.7510</td>\n      <td>NaN</td>\n      <td>185.61360</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>185.8598</td>\n      <td>264.3865</td>\n      <td>98.5349</td>\n      <td>132.5825</td>\n      <td>167.936567</td>\n      <td>164.66675</td>\n      <td>167.936567</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>169.7368</td>\n      <td>282.2762</td>\n      <td>94.6561</td>\n      <td>137.0460</td>\n      <td>155.459833</td>\n      <td>134.81425</td>\n      <td>155.459833</td>\n      <td>160.213925</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>109.4177</td>\n      <td>244.3414</td>\n      <td>88.9192</td>\n      <td>146.9556</td>\n      <td>138.861367</td>\n      <td>142.00080</td>\n      <td>138.861367</td>\n      <td>153.333775</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>197.5622</td>\n      <td>222.7239</td>\n      <td>59.7319</td>\n      <td>118.9471</td>\n      <td>134.316233</td>\n      <td>132.95135</td>\n      <td>134.316233</td>\n      <td>133.882800</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>176.1140</td>\n      <td>255.4585</td>\n      <td>73.3361</td>\n      <td>112.9922</td>\n      <td>126.298300</td>\n      <td>115.96965</td>\n      <td>126.298300</td>\n      <td>128.985225</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>178.6064</td>\n      <td>206.3817</td>\n      <td>52.1902</td>\n      <td>147.5705</td>\n      <td>126.503267</td>\n      <td>130.28135</td>\n      <td>126.503267</td>\n      <td>131.616350</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>112.8114</td>\n      <td>282.7631</td>\n      <td>57.7145</td>\n      <td>122.6909</td>\n      <td>127.751200</td>\n      <td>135.13070</td>\n      <td>127.751200</td>\n      <td>125.550175</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>145.0386</td>\n      <td>263.1664</td>\n      <td>84.1524</td>\n      <td>166.9814</td>\n      <td>145.747600</td>\n      <td>144.83615</td>\n      <td>145.747600</td>\n      <td>137.558750</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAttempting to accomplish a similar feat using method chaining will result in an error because the `.assign` method expects keyword arguments. The best way is to use the unpacking operator to achieve this with the help of dictionary comprehension to loop through the different values for the SMAs.\n\n::: {#e9e65984 .cell execution_count=15}\n``` {.python .cell-code}\ndef add_multiple_smas(df, col, *windows, **kwargs):\n    \n    # Use assign to add the columns in a chained fashion\n    return df.assign(**{f'SMA_{window}': df[col].rolling(window=window, **kwargs).mean() for window in windows})\n\n# Example usage with method chaining\nadd_multiple_smas(df2, 'Close', 2, 3, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Open</th>\n      <th>High</th>\n      <th>Low</th>\n      <th>Close</th>\n      <th>SMA</th>\n      <th>SMA_2</th>\n      <th>SMA_3</th>\n      <th>SMA_4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>177.3956</td>\n      <td>237.0798</td>\n      <td>87.9044</td>\n      <td>174.4762</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>143.8878</td>\n      <td>292.6765</td>\n      <td>67.7263</td>\n      <td>196.7510</td>\n      <td>NaN</td>\n      <td>185.61360</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>185.8598</td>\n      <td>264.3865</td>\n      <td>98.5349</td>\n      <td>132.5825</td>\n      <td>167.936567</td>\n      <td>164.66675</td>\n      <td>167.936567</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>169.7368</td>\n      <td>282.2762</td>\n      <td>94.6561</td>\n      <td>137.0460</td>\n      <td>155.459833</td>\n      <td>134.81425</td>\n      <td>155.459833</td>\n      <td>160.213925</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>109.4177</td>\n      <td>244.3414</td>\n      <td>88.9192</td>\n      <td>146.9556</td>\n      <td>138.861367</td>\n      <td>142.00080</td>\n      <td>138.861367</td>\n      <td>153.333775</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>197.5622</td>\n      <td>222.7239</td>\n      <td>59.7319</td>\n      <td>118.9471</td>\n      <td>134.316233</td>\n      <td>132.95135</td>\n      <td>134.316233</td>\n      <td>133.882800</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>176.1140</td>\n      <td>255.4585</td>\n      <td>73.3361</td>\n      <td>112.9922</td>\n      <td>126.298300</td>\n      <td>115.96965</td>\n      <td>126.298300</td>\n      <td>128.985225</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>178.6064</td>\n      <td>206.3817</td>\n      <td>52.1902</td>\n      <td>147.5705</td>\n      <td>126.503267</td>\n      <td>130.28135</td>\n      <td>126.503267</td>\n      <td>131.616350</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>112.8114</td>\n      <td>282.7631</td>\n      <td>57.7145</td>\n      <td>122.6909</td>\n      <td>127.751200</td>\n      <td>135.13070</td>\n      <td>127.751200</td>\n      <td>125.550175</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>145.0386</td>\n      <td>263.1664</td>\n      <td>84.1524</td>\n      <td>166.9814</td>\n      <td>145.747600</td>\n      <td>144.83615</td>\n      <td>145.747600</td>\n      <td>137.558750</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nMethod chaining in pandas allows for more concise, readable, and functional-style code by performing multiple transformations in a single statement without creating intermediate variables. This makes the code more compact and often easier to follow when handling complex data transformations. It can also help avoid side effects by keeping transformations within the same flow, making it easier to debug and maintain.\n\nHowever, it's also a matter of preference. Some developers prefer method chaining for its elegance and simplicity, while others prefer using intermediate variables for clarity, especially when dealing with more complex logic, as it can be easier to inspect the data at different stages of transformation. The choice depends on the coding style that the person or team finds most understandable and maintainable.\n\n\n## Conclusion\n\nUnpacking is a powerful feature in Python that helps you write cleaner and more efficient code. Whether you're unpacking lists, tuples, or dictionaries, or using `*args` and `**kwargs` in functions, this feature allows for flexible and dynamic code. Moreover, unpacking can be used with popular libraries like Pandas and NumPy to streamline data manipulation.\n\nSo, the next time you find yourself opening a gift box, remember: Python unpacking is just like unboxing—taking out each item, one by one, and making it yours!\n\n",
    "supporting": [
      "unpacking_operator_in_python_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}